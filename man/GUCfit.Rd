% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GUCfit.R
\name{GUCfit}
\alias{GUCfit}
\alias{GUCfit.formula}
\alias{print.GUCfit}
\alias{summary.GUCfit}
\title{Predicting the Underlying Causes of Death}
\usage{
\method{GUCfit}{formula}(
  formula,
  data,
  gc_to_uc,
  nm_id = "id",
  method = c("NB", "MLR"),
  prop_valid = 0.2,
  ...
)

GUCfit(formula, ...)

\method{print}{GUCfit}(x)

\method{summary}{GUCfit}(x)
}
\arguments{
\item{formula}{an object of class "formula": a symbolic description of the model to be fitted.
This should contain an outcome variable (as the underlying causes) and predictor variables if any.
Predictor variables put inside \code{multi()} are recognized as multiple causes. See \emph{Details §1} also.}

\item{data}{a data.frame or a list (with equal-length vectors) containing all the variables.}

\item{gc_to_uc}{a named matrix specifying the \emph{a priori} constraints for GC-UC mapping.
The row names are used as the Garbage Code (GC) levels and the column names are used as the Underlying Cause (UC) levels.
This is a required argument. See \emph{Details §2} also.}

\item{nm_id}{variable name of the identity key for the individual record.}

\item{method}{one of the following redistribution model, See \emph{Details §3} also.
\itemize{
\item "NB": Naive Bayes Classifier (default).
\item "MLR": Multinomial Logistic Regression implemented by \code{\link[nnet:multinom]{nnet::multinom()}}.
}}

\item{prop_valid}{proportion of data used in validation (default to 0.2). See \emph{Details §4} also.}

\item{...}{the following optional arguments are passed to redistribution methods.
\itemize{
\item \code{alp = 0.1} (default): The smoothing parameter in "NB" method , i.e. the additional counts added to all strata of the conditional probabilities.
\item \code{maxit = 100} (default): Maximum number of iterations in "MLR" method. Additional arguments for \code{nnet} can also be specified here. See \code{\link[nnet:nnet]{nnet::nnet()}} for details.
}}
}
\value{
A \code{GUCfit} object containing the following components.
\itemize{
\item \code{formula}: The formula same as the input
\item \code{pred_GUC}: The the predicted UC probabilities for each GC record. A data.frame where
the row identifying the individual records, and the column identifying the UC categories.
The  key \code{nm_id} is preserved to identify individual predictions.
\item \code{dat_info}: A data.frame summarizing the no. of records used for training, validation, and prediction.
\item \code{error_info}: A data.frame summarizing the error measures
\item \code{fit}: The fitted model.
\item \code{gcs}: A character vector listing the GC levels, same as the rownames of \code{gc_to_uc}.
\item \code{ucs}: A character vector listing the UC levels, same as the colnames of \code{gc_to_uc}.
\item \code{method}: The modeling method.
}
}
\description{
Fit a redistribution model to predict the Underlying Causes (UCs) from Garbage Codes (GCs). \strong{NHIRC-Usable}
\loadmathjax
}
\details{
\subsection{§1. Specify the model formula}{

The \code{formula} argument takes the general model form as in \code{lm()} or \code{glm()}. The form should be like \code{GUC ~ x1 + x2 + multi(MC1, MC2)},
where \code{GUC} is the name of the outcome variable (the underlying causes of death , UCs). The RHS of \code{~} contains the names of predictors used by the model. Here,
\code{x1} and \code{x2} represent the normal predictor variables as in common regression models. \code{multi(...)} is used to specify the multiple causes of death (here, \code{MC1} and \code{MC2}).
\code{multi(...)} is treated differently in different methods. In "NB", \code{multi(...)} seen as item-sets to calculate the conditional probabilities. See the reference paper for details.
In "MLR", \code{multi(...)} is transformed into many binary variables indicating whether one cause of death item exist. \strong{There should be only one \code{multi(...)} term in the formula}.
Also, \strong{only factor or character variables are accepted}.
}

\subsection{§2. Specify the GC-UC mapping constraints}{

The GC-UC mapping constraints \code{gc_to_uc} should be a named matrix. \strong{The row names and column names are required} as the row names define the GC categories,
and the column names define the UC categories. The entries of this matrix (\mjseqn{A}) should be binary, so that \mjseqn{A_{ij} = 1} denotes
the permission to redistribute \mjseqn{i}-th GC category to \mjseqn{j}-th UC category, otherwise, \mjseqn{A_{ij} = 0}.
}

\subsection{§3. Redistributing GCs to UCs}{

Records with UCs (defined in \code{gc_to_uc}) in the outcome variable are used to train the "NB" or "MLR" model. Then, the trained model is used to
predict the UCs for those having GC outcomes. Generally, "NB" is recommended as it better handles missing data and large number of UC categories (more accurate and efficient) .
However, "MLR" can perform better with more complete data and small number of UC categories. We recommend using validation procedure to compare the two methods
before full implementation.
}

\subsection{§4. Validation and the error measures}{

When the proportion of validation (\code{prop_valid} = 0.2 by default) is greater than zero, a random proportion of records with UCs is erserved for validation.
Binary and cross entropy error measures are used to evaluate the model performance.
Use \code{summary()} to the returned \code{GUCfit} object to see the average errors in the training and validation partition.
}
}
\section{Methods (by class)}{
\itemize{
\item \code{GUCfit}: Print the basics (GC/UC levels, redistribution method) of GUCfit

\item \code{GUCfit}: Print the details (variable importance, errors) of GUCfit
}}

\examples{
\dontrun{
# load demo dataset
data("multideath")

# create a full gc_to_uc matrix
gucs <- sort(unique(multideath$GUC))
gc_to_uc = matrix(1, 10, 97, dimnames = list(gucs[98:107], gucs[1:97]))

# predictors have to be factors or characters
d <- multideath
d$x1 <- factor(d$x1)
d$x2 <- factor(d$x2)
d$x3 <- factor(d$x3)

# fit a NB model
fit1 <- GUCfit(
  formula = GUC ~ age + x1  + x2  + x3 + multi(MC1, MC2, MC3),
  data = d, gc_to_uc = gc_to_uc,
  nm_id = "id", method = "NB", prop_valid = 0.2)

# summarizing the results
summary(fit1)
}

}
\references{
Ng, T. C., Lo, W. C., Ku, C. C., Lu, T. H., & Lin, H. H. (2020). Improving the use of mortality data in public health: A comparison of garbage code redistribution models. American journal of public health, 110(2), 222-229.
}
\seealso{
\link{multideath} for the demo dataset, \link[nnet:multinom]{nnet::multinom} for the underlying MLR method.
}
